"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3822],{1685:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>d});var o=t(4848),r=t(8453);const a={sidebar_position:1},i="5-Minute Quick Start",s={id:"quickstart",title:"5-Minute Quick Start",description:"It's easy to build a local-first web application with real-time synchronization using Automerge. In this quickstart, we'll start with the standard yarn create vite example Typescript application and use Automerge to turn it into a simple local-first application.",source:"@site/docs/quickstart.md",sourceDirName:".",slug:"/quickstart",permalink:"/docs/quickstart",draft:!1,unlisted:!1,editUrl:"https://github.com/automerge/automerge.github.io/edit/main/docs/quickstart.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Welcome to Automerge",permalink:"/docs/hello"},next:{title:"Concepts",permalink:"/docs/concepts"}},c={},d=[{value:"Setup",id:"setup",level:2},{value:"Initializing a repository",id:"initializing-a-repository",level:2},{value:"Creating (or finding) a document",id:"creating-or-finding-a-document",level:2},{value:"Working with the document",id:"working-with-the-document",level:2},{value:"Updating your app to use Automerge",id:"updating-your-app-to-use-automerge",level:2},{value:"Collaborating over the internet",id:"collaborating-over-the-internet",level:2},{value:"Saving the document",id:"saving-the-document",level:2},{value:"More",id:"more",level:2}];function l(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h1,{id:"5-minute-quick-start",children:"5-Minute Quick Start"}),"\n",(0,o.jsxs)(n.p,{children:["It's easy to build a local-first web application with real-time synchronization using Automerge. In this quickstart, we'll start with the standard ",(0,o.jsx)(n.code,{children:"yarn create vite"})," example Typescript application and use Automerge to turn it into a simple local-first application."]}),"\n",(0,o.jsxs)(n.p,{children:["All the code here can be found at the ",(0,o.jsx)(n.a,{href:"https://github.com/automerge/automerge-repo-quickstart",children:"automerge-repo-quickstart"})," repo."]}),"\n",(0,o.jsx)(n.p,{children:"Let's begin."}),"\n",(0,o.jsx)(n.h2,{id:"setup",children:"Setup"}),"\n",(0,o.jsx)(n.p,{children:"First, let's initialize an off-the-shelf React app using Vite as our bundler. We're not going to remind you along the way, but we recommend you initialize a git repo and check in the code at whatever interval feels comfortable."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"$ yarn create vite\n# Project name: hello-automerge-repo\n# Select a framework: React\n# Select a variant: TypeScript\n\n$ cd hello-automerge-repo\n$ yarn\n"})}),"\n",(0,o.jsx)(n.p,{children:"Next, we'll add some automerge dependencies for the project. We'll introduce each of these libraries as they come up in the tutorial."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"yarn add @automerge/automerge \\\n  @automerge/automerge-repo \\\n  @automerge/automerge-repo-react-hooks \\\n  @automerge/automerge-repo-network-broadcastchannel \\\n  @automerge/automerge-repo-storage-indexeddb \\\n  vite-plugin-wasm\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Because Vite support for WebAssembly modules (used by Automerge) currently requires configuring a plugin, replace ",(0,o.jsx)(n.code,{children:"vite.config.ts"})," with the following:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"// vite.config.ts\nimport { defineConfig } from 'vite'\nimport react from '@vitejs/plugin-react'\nimport wasm from 'vite-plugin-wasm'\n\nexport default defineConfig({\n  plugins: [wasm(), react()],\n\n  worker: {\n    format: 'es',\n    plugins: () => [wasm()],\n  },\n})\n"})}),"\n",(0,o.jsx)(n.p,{children:"With that out of the way, we're ready to build the application."}),"\n",(0,o.jsx)(n.h1,{id:"using-automerge",children:"Using Automerge"}),"\n",(0,o.jsxs)(n.p,{children:["The central concept of Automerge is one of ",(0,o.jsx)(n.a,{href:"./documents/",children:"documents"}),". An Automerge document is a JSON-like data structure that is kept synchronized between all communicating peers with the same document ID."]}),"\n",(0,o.jsxs)(n.p,{children:["To create or find Automerge documents, we'll use a ",(0,o.jsx)(n.a,{href:"./repositories/",children:"Repo"}),". The Repo (short for repository) keeps track of all the documents you load and makes sure they're properly synchronized and stored."]}),"\n",(0,o.jsxs)(n.p,{children:["Let's go ahead and make one. Add the following imports to ",(0,o.jsx)(n.code,{children:"src/main.tsx"}),":"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"import { isValidAutomergeUrl, Repo } from '@automerge/automerge-repo'\nimport { BroadcastChannelNetworkAdapter } from '@automerge/automerge-repo-network-broadcastchannel'\nimport { IndexedDBStorageAdapter } from '@automerge/automerge-repo-storage-indexeddb'\nimport { next as A } from '@automerge/automerge' //why `next`? See the the \"next\" section of the conceptual overview\n"})}),"\n",(0,o.jsx)(n.h2,{id:"initializing-a-repository",children:"Initializing a repository"}),"\n",(0,o.jsx)(n.p,{children:"Before we can start finding or creating documents, we'll need a repo. Here, we create one that can synchronize with other tabs using a sort of pseudo-network built into the browser that allows communication between tabs with the same shared origin: the BroadcastChannel."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"const repo = new Repo({\n  network: [new BroadcastChannelNetworkAdapter()],\n  storage: new IndexedDBStorageAdapter(),\n})\n"})}),"\n",(0,o.jsx)(n.h2,{id:"creating-or-finding-a-document",children:"Creating (or finding) a document"}),"\n",(0,o.jsx)(n.p,{children:"Now that we have the repo, we want to either create a document if we don't have one already or we want to load a document. To keep things simple, we'll check the URL hash for a document ID, and if we don't find one, we'll start a new document and set it in the hash."}),"\n",(0,o.jsx)(n.p,{children:"Add this code right after the repo initialization code."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"const rootDocUrl = `${document.location.hash.substring(1)}`\nlet handle\nif (isValidAutomergeUrl(rootDocUrl)) {\n  handle = repo.find(rootDocUrl)\n} else {\n  handle = repo.create<{ counter?: A.Counter }>()\n  handle.change(d => (d.counter = new A.Counter()))\n}\nconst docUrl = (document.location.hash = handle.url)\n// @ts-expect-error we'll use this later for experimentation\nwindow.handle = handle\n"})}),"\n",(0,o.jsx)(n.p,{children:"A real application would probably handle routing differently, but this is enough to get started."}),"\n",(0,o.jsx)(n.h2,{id:"working-with-the-document",children:"Working with the document"}),"\n",(0,o.jsxs)(n.p,{children:["The main way of interacting with a Repo is through ",(0,o.jsx)(n.code,{children:"DocHandles"}),", which allow you to read data from a document or make changes to it, and which emit ",(0,o.jsx)(n.code,{children:'"change"'})," events whenever the document changes -- either through local actions or over the network."]}),"\n",(0,o.jsx)(n.p,{children:"Now that we have a document handle stuck onto the window, let's experiment with it. Start your application now with:"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.code,{children:"$ yarn dev"})}),"\n",(0,o.jsxs)(n.p,{children:["You won't see any changes from the default example application on screen, but we've attached an Automerge document to the ",(0,o.jsx)(n.code,{children:"window"})," object, which makes it conveniently available in the Chrome debugger."]}),"\n",(0,o.jsx)(n.p,{children:"Your new document is empty, because we just created it. Let's start by initializing a counter. Run the following command in your Chrome debugger."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"handle.change(d => {\n  d.counter.increment(10)\n})\n"})}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"DocHandle.change"})," allows you to modify the document managed by a ",(0,o.jsx)(n.code,{children:"DocHandle"})," and takes care of storing new changes and notifying any peers of new changes."]}),"\n",(0,o.jsx)(n.p,{children:"Next, run this code to see the contents of your document. The contents will look a bit complex, but you should see a counter with a value of 10 if you poke around."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"handle.docSync()\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Calling ",(0,o.jsx)(n.code,{children:"DocHandle.docSync()"})," return the current value of the document synchronously, or returns undefined if the document is unavailable either because it is still loading, or because it can't be found. To avoid this problem, prefer the asynchronous form: ",(0,o.jsx)(n.code,{children:"await handle.doc()"}),". If you want to render loading states differently from an unavailable state, you can inspect ",(0,o.jsx)(n.code,{children:"handle.state"})," and branch accordingly."]}),"\n",(0,o.jsx)(n.h2,{id:"updating-your-app-to-use-automerge",children:"Updating your app to use Automerge"}),"\n",(0,o.jsxs)(n.p,{children:["We've already created or fetched our initial document via ",(0,o.jsx)(n.code,{children:"main.tsx"}),", but usually when we want to work with a document in a React application, we will refer to it by URL. Let's start by editing the call signature for ",(0,o.jsx)(n.code,{children:"App.tsx"})," to pass in the URL for your newly created document, and then make it available to your component with the ",(0,o.jsx)(n.code,{children:"useDocument"})," hook."]}),"\n",(0,o.jsxs)(n.p,{children:["We also need to make the ",(0,o.jsx)(n.code,{children:"repo"})," object we created available throughout the application, so we use a React Context provider for that. In ",(0,o.jsx)(n.code,{children:"main.tsx"}),", modify the ",(0,o.jsx)(n.code,{children:"React.render()"})," call to look like this:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"ReactDOM.createRoot(document.getElementById('root')!).render(\n  <React.StrictMode>\n    <RepoContext.Provider value={repo}>\n      <App docUrl={docUrl}/>\n    </RepoContext.Provider>\n  </React.StrictMode>,\n)\n"})}),"\n",(0,o.jsx)(n.p,{children:"and also add another import line:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"import { RepoContext } from '@automerge/automerge-repo-react-hooks'\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Inside ",(0,o.jsx)(n.code,{children:"App.tsx"}),", add these imports:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"import { AutomergeUrl } from '@automerge/automerge-repo'\nimport { useDocument } from '@automerge/automerge-repo-react-hooks'\nimport { next as A } from '@automerge/automerge'\n"})}),"\n",(0,o.jsx)(n.p,{children:"and change the first few lines to these:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"interface CounterDoc {\n  counter: A.Counter\n}\n\nfunction App({docUrl}: {docUrl: AutomergeUrl}) {\n  const [doc, changeDoc] = useDocument<CounterDoc>(docUrl)\n"})}),"\n",(0,o.jsx)(n.p,{children:"Now you've got access to the document in a more native React-style way: a hook that will update every time the document changes."}),"\n",(0,o.jsxs)(n.p,{children:["Our last step here is to change our code to use these new values by replacing how we render the ",(0,o.jsx)(n.code,{children:"button"})," element."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"        <button onClick={() => changeDoc((d) => d.counter.increment(1))}>\n          count is { doc && doc.counter.value }\n        </button>\n"})}),"\n",(0,o.jsx)(n.p,{children:"Go ahead and try this out. Open a second (or third) tab with the same URL and see how as you click the counter in any tab, the others update."}),"\n",(0,o.jsx)(n.p,{children:"If you close all the tabs and reopen them, the counter value is preserved."}),"\n",(0,o.jsx)(n.p,{children:"Congratulations! You have a working Automerge-backed React app with live local synchronization. How does it work? We'll learn through some experimentation in the next section."}),"\n",(0,o.jsx)(n.h2,{id:"collaborating-over-the-internet",children:"Collaborating over the internet"}),"\n",(0,o.jsxs)(n.p,{children:["The handle we have created has a URL, we can access that with ",(0,o.jsx)(n.code,{children:"DocHandle.url"}),", this URL can be used to sync the document with any peer who has it. Open up your browser debugger and run ",(0,o.jsx)(n.code,{children:"console.log(handle.url)"}),", this should print something that looks like ",(0,o.jsx)(n.code,{children:'"automerge:45NuQi1e45PKsemx8GhSCu62gyag"'}),", make a note of this for later."]}),"\n",(0,o.jsxs)(n.p,{children:["First, we'll add a network adapter to the ",(0,o.jsx)(n.code,{children:"Repo"})," in our web app which syncs to a sync server via a websocket. Add the following dependency to the web app we've been building:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"yarn add @automerge/automerge-repo-network-websocket\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Then add a network adapter connecting the repo to ",(0,o.jsx)(n.code,{children:"sync.automerge.org"})]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{children:"// main.tsx\n// Add this import\nimport { BrowserWebSocketClientAdapter } from \"@automerge/automerge-repo-network-websocket\"\n\n...\n\n// now update the repo definition to look like this:\nconst repo = new Repo({\n    network: [\n        new BroadcastChannelNetworkAdapter(),\n        // This is the new line\n        new BrowserWebSocketClientAdapter('wss://sync.automerge.org')\n    ],\n    storage: new IndexedDBStorageAdapter(),\n})\n"})}),"\n",(0,o.jsxs)(n.p,{children:["This creates a repo which syncs changes it sees to ",(0,o.jsx)(n.code,{children:"sync.automerge.org"}),", and any other process can connect to that server and use the URL to get the changes we've made."]}),"\n",(0,o.jsx)(n.admonition,{type:"note",children:(0,o.jsxs)(n.p,{children:["The Automerge project provides a public sync server for you to experiment with ",(0,o.jsx)(n.code,{children:"sync.automerge.org"}),". This is not a private instance, and as an experimental service has no reliability or data safety guarantees. Basically, it's good for demos and prototyping, but run your own sync server for production uses."]})}),"\n",(0,o.jsx)(n.p,{children:"To see this in action we'll create a little node app. Change into a clean directory and run"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-bash",children:"npm create @automerge/repo-node-app amg-quickstart\ncd amg-quickstart\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Now open ",(0,o.jsx)(n.code,{children:"index.js"})," and add the following:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"// repo is already set up by the `repo-node-app` helper\nconst doc = repo.find('<url copied from the debugger>')\nconsole.log(await doc.doc())\n// This is required because we don't have a way of shutting down the repo\nsetTimeout(() => process.exit(), 1000)\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Now run this with ",(0,o.jsx)(n.code,{children:"node index.js"})," and you should see the contents of the document."]}),"\n",(0,o.jsxs)(n.p,{children:["Now add the following at the end of ",(0,o.jsx)(n.code,{children:"index.js"})," (but before the setTimeout)"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"doc.change(d => {\n  d.counter.increment(1)\n})\n"})}),"\n",(0,o.jsxs)(n.p,{children:["This change will be reflected in any connected and listening handles. Go back to the original browser window and watch it as you run ",(0,o.jsx)(n.code,{children:"node index.js"}),". What you should see is that every time you run the script the counter in the browser changes."]}),"\n",(0,o.jsx)(n.h2,{id:"saving-the-document",children:"Saving the document"}),"\n",(0,o.jsxs)(n.p,{children:["If you provide a ",(0,o.jsx)(n.code,{children:"Repo"})," with a ",(0,o.jsx)(n.code,{children:"StorageAdapter"})," then it will save documents for use later. In the browser we used IndexedDB:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-js",children:"import { IndexedDBStorageAdapter } from '@automerge/automerge-repo-storage-indexeddb'\nimport { BrowserWebSocketClientAdapter } from '@automerge/automerge-repo-network-websocket'\n\nconst repo = new AutomergeRepo.Repo({\n  network: [new BrowserWebSocketClientAdapter('wss://sync.automerge.org')],\n  storage: new IndexedDBStorageAdapter(),\n})\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Documents will be stored in ",(0,o.jsx)(n.code,{children:"IndexedDB"})," and methods like ",(0,o.jsx)(n.code,{children:"Repo.find"})," will consult storage when loading. The upshot is that if you had a document locally, it will continue to be available regardless of whether you are connected to any peers."]}),"\n",(0,o.jsx)(n.h2,{id:"more",children:"More"}),"\n",(0,o.jsxs)(n.p,{children:["If you're hungry for more, look in the ",(0,o.jsx)(n.a,{href:"/docs/cookbook/modeling-data/",children:"Cookbook"})," section."]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>s});var o=t(6540);const r={},a=o.createContext(r);function i(e){const n=o.useContext(a);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),o.createElement(a.Provider,{value:n},e.children)}}}]);